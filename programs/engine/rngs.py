"""
Module implementing the DASRandom, the random number generator used by DAS.
Usage:
from programs.engine.rngs import DASRandom
rng_factory = DASRandom
rng = rng_factory().randomState()
rng.geometric(p) retruns a random geometric
RNGs (primarily those, based on hardware, i.e. using RDRAND instruction)
and wrapping them into an interface identical to numpy.random for calling distributions
"""
import sys
import logging
import numpy as np


def DASRandom():
    """Return the RNG used by the DAS"""
    logging.info("Using randomgen.RDRAND() as random bit generator")
    import randomgen
    return np.random.Generator(randomgen.RDRAND())


def DASRandomBuffered():
    import randomgen

    class RDRandLemir:
        """
        Class buffering raw bytes generated by RDRAND, and yielding them one by one
        converting into uniformly distributed integers using Daniel Lemire method,
        which is also used bu NumPy.

        Lemire method of mapping random bytes to uniform [0, s), with removing bias via rejection sampling
        https://arxiv.org/abs/1805.10941
        https://github.com/lemire/fastrange
        https://lemire.me/blog/2016/06/30/fast-random-shuffling/
        https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/

        Used in numpy for randint
        https://github.com/numpy/numpy/blob/43f80863ba2994a186293d86d516204ef38b0043/numpy/random/src/distributions/distributions.c#L1145-L1653

        Require: source of uniformly-distributed random integers in [0, 2^L)
        Require: target interval [0, s) with s ∈ [0, 2^L)
            1: x ← random integer in [0, 2^L)
            2: m ← x * s
            3: l ← m mod 2^L
            4: if l < s then                                {Application of the rejection method}
            5:     t ← (2^L − s) mod s                      {2^L mod s = (2^L − s) mod s}, in C implementations with uint-size-2L types can be written as -s % s
            6:     while l < t do
            7:         x ← random integer in [0, 2^L)
            8:         m ← x × s
            9:         l ← m mod 2^L
            10:    end while
            11: end if
            12: return m ÷ 2^L


        C implementation for 32bit integer:

              uint64_t random32bit =  random32(); //32-bit random number
              multiresult = random32bit * range;
              leftover = (uint32_t) multiresult;
              if(leftover < range ) {
                  threshold = -range % range ;
                  while (leftover < threshold) {
                        random32bit =  random32();
                        multiresult = random32bit * range;
                        leftover = (uint32_t) multiresult;
                  }
               }
              return multiresult >> 32;
        """

        def __init__(self):
            self.bitgen = randomgen.RDRAND()

        # def nextint(self, nbytes):
        #     return int.from_bytes(self.bitgen.random_raw(nbytes // 8).tobytes(), sys.byteorder)

        def integers(self, low=0, high=0):
            """ Lemir method for int64"""
            rangelen = high - low
            if rangelen < 1:
                raise ValueError(f"Interval length is not positive, high={high}, low={low}")
            elif rangelen == 1:
                return low
            elif rangelen == 2:
                # return self.bitgen.random_raw() & 1    # Get 1 bit (last)
                return self.bitgen.random_raw() >> 63    # Get 1 bit (first)
            # elif rangelen == 4:
            #     # return self.bitgen.random_raw() & 3    # Get 2 bits (last)
            #     return self.bitgen.random_raw() >> 62    # Get 2 bits (first)
            # nbytes = max(8, int(math.ceil(math.log2(rangelen) / 8)))
            nbytes = 8                                    # int [0, 2^L) where L is number of bits, and nbytes = L/8 is number of bytes
            L = nbytes * 8
            two_to_L = 1 << L                             # 2^L
            maxuint = two_to_L - 1
            # random_Lbit = self.nextint(nbytes)
            random_Lbit = self.bitgen.random_raw()
            multiresult = int(random_Lbit) * rangelen
            leftover = multiresult & maxuint              # multresult mod 2^L
            if leftover < rangelen:
                threshold = (two_to_L - rangelen) % rangelen
                while leftover < threshold:
                    # multiresult = self.nextint(nbytes) * rangelen
                    multiresult = int(self.bitgen.random_raw()) * rangelen
                    leftover = multiresult & maxuint
            return low + multiresult >> L                       # multresult // 2^L

        def randint(self, *args, **kwargs):
            return self.integers(*args, **kwargs)

    return RDRandLemir()
